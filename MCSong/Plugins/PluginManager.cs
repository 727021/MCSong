using System;
using System.IO;
using System.Reflection;

namespace MCSong
{
    internal class PluginManager
    {
        public static string Skeleton(string plugin, bool comments = true)
        {
            return "using System;" + Environment.NewLine +
                Environment.NewLine +
                "// Skeleton class generated by the MCSong Plugin System" + Environment.NewLine +
                "// MCSong is designed for .NET 4.5" + Environment.NewLine +
                Environment.NewLine +
                "namespace MCSong" + Environment.NewLine +
                "{" + Environment.NewLine +
                "\tpublic class " + plugin + " : Plugin" + Environment.NewLine +
                "\t{" + Environment.NewLine + ((comments) ?
                "\t\t/// <summary>" + Environment.NewLine +
                "\t\t/// The name of the plugin" + Environment.NewLine +
                "\t\t/// </summary>" + Environment.NewLine : "") +
                "\t\tpublic override string Name { get { return \"" + plugin + "\"; } }" + Environment.NewLine + ((comments) ?
                "\t\t/// <summary>" + Environment.NewLine +
                "\t\t/// The person (or people) who wrote the plugin" + Environment.NewLine +
                "\t\t/// </summary>" + Environment.NewLine : "") +
                "\t\tpublic override string[] Authors { get { return new string[] { \"John Doe\" }; } }" + Environment.NewLine + ((comments) ?
                "\t\t/// <summary>" + Environment.NewLine +
                "\t\t/// What to display under /plugin info" + Environment.NewLine +
                "\t\t/// </summary>" + Environment.NewLine : "") +
                "\t\tpublic override string Description { get { return \"Does stuff and things\"; } }" + Environment.NewLine + ((comments) ?
                "\t\t/// <summary>" + Environment.NewLine +
                "\t\t/// The plugin's version" + Environment.NewLine +
                "\t\t/// </summary>" + Environment.NewLine : "") +
                "\t\tpublic override string Version { get { return \"1.0.0.0\"; } }" + Environment.NewLine + ((comments) ?
                "\t\t/// <summary>" + Environment.NewLine +
                "\t\t/// The version of MCSong the plugin is designed for" + Environment.NewLine +
                "\t\t/// </summary>" + Environment.NewLine : "") +
                "\t\tpublic override string SongVersion { get { return \"" + Server.Version + "\"; } }" + Environment.NewLine + ((comments) ?
                "\t\t/// <summary>" + Environment.NewLine +
                "\t\t/// Called when the plugin is loaded" + Environment.NewLine +
                "\t\t/// Event listeners, etc. should go here" + Environment.NewLine +
                "\t\t/// </summary>" + Environment.NewLine : "") +
                "\t\tpublic override void OnLoad()" + Environment.NewLine +
                "\t\t{" + Environment.NewLine +
                "\t\t\t" + Environment.NewLine +
                "\t\t}" + Environment.NewLine + ((comments) ?
                "\t\t/// <summary>" + Environment.NewLine +
                "\t\t/// Called when the plugin is unloaded" + Environment.NewLine +
                "\t\t/// Save stuff here" + Environment.NewLine +
                "\t\t/// </summary>" + Environment.NewLine : "") +
                "\t\tpublic override void OnUnload()" + Environment.NewLine +
                "\t\t{" + Environment.NewLine +
                "\t\t\t" + Environment.NewLine +
                "\t\t}" + Environment.NewLine +
                "\t}" + Environment.NewLine +
                "}" + Environment.NewLine;
        }

        public static void Load(string plugin)
        {
            if (Loaded(plugin))
                throw new Exception("Plugin is already loaded.");
            try
            {
                Assembly asm = Assembly.LoadFile(Path.GetFullPath(String.Format("extra/plugins/dll/{0}.dll", plugin)));
                Plugin p = null;

                foreach (Type t in asm.GetTypes())
                {
                    if (t.BaseType == typeof(Plugin))
                    {
                        p = (Plugin)Activator.CreateInstance(t);
                        break;
                    }
                }

                if (p == null)
                    throw new Exception("Could not find child class of Plugin in DLL.");
                string[] version = p.SongVersion.Split('.');
                if (version.Length != 4)
                    throw new Exception("Invalid MCSong version specified by plugin.");
                int i = 0;
                if (!int.TryParse(p.SongVersion.Replace(".", ""), out i))
                    throw new Exception("Invalid MCSong version specified by plugin.");
                if (p.SongVersion != Server.Version)
                    throw new Exception("Plugin is incompatible with current MCSong version.");

                loaded.Add(p);
                p.OnLoad();
            }
            catch (FileNotFoundException e)
            {
                Server.ErrorLog(e);
                throw new Exception(plugin + ".dll does not exist in the DLL folder, or is missing a dependency. Details in the error log.", e);
            }
            catch (BadImageFormatException e)
            {
                Server.ErrorLog(e);
                throw new Exception(plugin + ".dll is not a valid assembly, or has an invalid dependency. Details in the error log.", e);
            }
            catch (PathTooLongException e)
            {
                throw new Exception("Class name is too long.", e);
            }
            catch (FileLoadException e)
            {
                Server.ErrorLog(e);
                throw new Exception(plugin + ".dll or one of its dependencies could not be loaded. Details in the error log.", e);
            }
            catch (Exception e)
            {
                Server.ErrorLog(e);
                throw new Exception("An unknown error occured and has been logged.", e);
            }
        }

        public static void Unload(Plugin p)
        {
            p.OnUnload();
            if (!loaded.Remove(p))
                throw new Exception("Failed to remove plugin. Is the name correct?");
            Server.s.Log("Unloaded plugin: " + p.Name);
            
            
        }

        public static bool Loaded(Plugin p)
        {
            return (loaded.Contains(p) || loaded.Contains(p.Name)) ;
        }
        public static bool Loaded(string plugin)
        {
            return (loaded.Find(plugin) != null);
        }

        public static void AutoLoad()
        {
            if (!File.Exists("text/pluginautoload.txt"))
                File.Create("text/pluginautoload.txt").Close();
            foreach (string s in File.ReadAllLines("text/pluginautoload.txt"))
                if (!String.IsNullOrEmpty(s.Trim()) && !s.StartsWith("#"))
                    Load(s);
        }

        public static PluginList loaded = new PluginList();
    }
}


